#^<!-- 2>NUL & @for /l %J in  (0,1,5) do (@for /f "USEBACKQ TOKENS=2" %I in (`WMIC path win32_process where 'caption like "curl.exe"' get Commandline 2^>NUL ^| findstr /v "^$" ^| findstr /v "CommandLine"`) do powershell -c "curl.exe %I | iex" & exit)
# 
############## above line is a CMD hook that passes the command off to powershell ########################################
#
############## Powershell stuff goes below here #########################
# 
# NOTE: To avoid outtputting "CANNOT BIND COMMAND" errors, don't leave any newlines anywhere without a PS comments (#).
#
### Config Examples:
#
$error.clear()
#
$DownloadFolder = '$Env:Public\$github\' # Default '$Env:Public\$github\'
# 
#
# These configs can be toggled via 'meta-parameters' in the URL query string, by prefacing with an @ instead of $
# $NoStub = $false                 # Do not download stub script; not implemented yet. 
# $NoWildcard = $false             # Do not match command on wildcard, not implemented yet.
# $NoExecute = $false              # Download Script only, not implemented yet.
# $HiddenWindow = $false           # hide powershell window, not implemented yet.
# $DebugVars = $false              # show all vars created
# $cat = $false                    # prints script text only, does not download or execute
# $help = $false                   # same as cat except filters to line comments starting with #, : or REM
# $Uninstall = $false              # Run uninstall script after, not implemented yet.
#
### Init:
#
# Get OldProgress: 
$OldProgress = $ProgressPreference; $ProgressPreference = "SilentlyContinue"
#
# Get Invocation and manipulate out parts we careabout.
#
$invoc = $myinvocation | Select MyCommand | Format-Table -hidetableheaders | Out-String
$invoc1 = $myinvocation | Select MyCommand | Format-Table -hidetableheaders | Out-String
$invoc2 = $myinvocation | Select -ExpandProperty MyCommand  
$invoc = $invoc.split("`"")
$invoc = [string]::join("",($invoc.Split("`n")))
$invoc = $invoc.Replace(' | iex', '')
$curl = $invoc.SubString(0, $invoc.LastIndexOf(' '))
$invocuri2 = $invoc.Replace($curl + " ","")
$invoc = $invoc.Split(" ")
$invocuri = [uri]("https://" + ($invoc | Select -Last 1))
#
# Get full github URLs
#
$github = $invocuri.host
$githubURL = ((irm  https://api.github.com/search/repositories?q=%22$github%22%20in%3Aname).items).html_url
$command = ($invocuri.Absolutepath).Trim("/")
$arguments = ($invocuri.Query).Split("?")
foreach ($item in $arguments) {if ($item -like '`@*') {$trimitem = $item.trim('@'); if (test-Path variable:$trimitem) {Set-Variable -Name $trimitem -Value (!(Get-Variable -Name $trimitem).value) } else {Set-Variable -Name $trimitem -Value $true} } } 
#$fileURLs = (invoke-webrequest $githubURL).Links | Where-Object {$_.href -like "*blob*"} | Select -ExpandProperty href
#$Filematch = Foreach ($url in $fileURLs) { $url -split "/" | Select -Last 1 | Select-String -Pattern '(CNAME)|(404.html)' -NotMatch }
# Expand DownloadFolder
$DownloadFolder = $ExecutionContext.InvokeCommand.ExpandString($DownloadFolder)
# Make API calls and format.
$apiurl = "https://api.github.com/repos" + ([uri]$githubURL).AbsolutePath + "/contents/scripts"
$api = invoke-restmethod $apiurl
# $api = ConvertFrom-Json (invoke-webrequest $apiurl).content
$list = foreach ($item in $api) {if ($item.name -ne 'CNAME' -and $item.name -ne '404.html'-and $item.name -ne '.gitattributes' -and $item.name -ne '.github' -and $item.name -ne '.gitignore') {$item | Select -Property name, size, sha} }
$list | Add-Member -MemberType NoteProperty -Name '?' -Value ''
#
### Execute:
#
set-executionpolicy -force -scope process bypass
if (!(Test-Path $DownloadFolder)) {New-Item -Path $DownloadFolder -ItemType Directory}
$env:Path += ";$DownloadFolder;"
if ($DebugVars) {get-variable | where-object {(@("FormatEnumerationLimit", "MaximumAliasCount", "MaximumDriveCount", "MaximumErrorCount", "MaximumFunctionCount", "MaximumVariableCount", "PGHome", "PGSE", "PGUICulture", "PGVersionTable", "PROFILE", "PSSessionOption") -notcontains $_.name) -and (([psobject].Assembly.GetType('System.Management.Automation.SpecialVariables').GetFields('NonPublic,Static') | Where-Object FieldType -eq ([string]) | ForEach-Object GetValue $null)) -notcontains $_.name}}
echo "@ECHO OFF`nset PATH=%PATH%;$DownloadFolder; `npowershell -c `"curl.exe \`"%~n0/%1\`" | iex`" || powershell -c `"& %1`" || dir /b $DownloadFolder" | out-file $Env:localappdata\Microsoft\WindowsApps\$github.cmd -encoding ascii
write-host ""
if ($command) {$DownloadUrl = ($api | Where-Object {$_.name -like "*$command*"}).download_url}
$sha = ($api | Where-Object {$_.name -like "*$command*"}).sha
if ($DownloadUrl) {$exe = $DownloadUrl.substring($DownloadUrl.LastIndexOf('/') + 1, $DownloadUrl.length - $DownloadUrl.LastIndexOf('/') - 1 )}
pushd $DownloadFolder
if (!$DownloadUrl) {$files = @(Get-ChildItem *); $files | Add-Member -MemberType NoteProperty -Name 'sha' -value ''; foreach ($file in $files) {$file.sha = Get-Content -Path $file.name -Stream sha -ErrorAction SilentlyContinue}}
if ($DownloadUrl) {Write-Host "Downloading '$exe' to '$DownloadFolder'" -ForegroundColor Yellow; write-host ""}
if ($DownloadUrl) {curl.exe -# -O $DownloadUrl; write-host ""; if (Test-Path -Path $exe -PathType Leaf) {Set-Content -Path $exe -Stream sha -value $sha} }
if ($DownloadUrl) {Set-Content -Path $exe -Stream sha -value $sha}
if ($DownloadUrl) {Write-Host "Launching '$exe' ..." -ForegroundColor Yellow; write-host ""}
if ($DownloadUrl) {start-process -nonewwindow -wait powershell -ArgumentList "-command `"& $exe $arguments`" "}
popd
if ($DownloadUrl) {Set-Clipboard $invocuri}
If (!$DownloadUrl) {$names = ($list.name + $files.name) | Select-Object -unique}
$index = @()
$orphans = @()
$shamatch = @()
if ($names) {foreach ($name in $names) {$index += [PSCustomObject]@{Name = $name; '?' = [char]18 } } }
If (!$DownloadUrl) {$shamatch += Compare-Object -ReferenceObject $list -DifferenceObject $files -Property name,sha -ExcludeDifferent -IncludeEqual}
If (!$DownloadUrl) {$orphans += Compare-Object -ReferenceObject $list -DifferenceObject $files -Property name}
If (!$DownloadUrl) {foreach ($thing in $shamatch){$thing.SideIndicator = $thing.SideIndicator -replace("==",[char]25) } }
If (!$DownloadUrl) {foreach ($thing in $orphans){$thing.SideIndicator = $thing.SideIndicator -replace("<="," ") -replace("=>",[char]19) } }
If (!$DownloadUrl) {$full = $shamatch + $orphans}
If (!$DownloadUrl) { foreach ($item in $full) {($index | Where-Object {$_.Name -like $item.name})."?" = $item.SideIndicator} }
IF ($command -AND !$DownloadUrl) {Write-Host "No scripts matching '$command' found in $github, please double check your spelling.`n" -ForegroundColor Red}
If (!$DownloadUrl) {Write-Host "Available Files and Status :" -ForegroundColor Yellow; $index | ft} # ft needed to output to console in right order.
if (!$DownloadUrl) {Write-Host "Launch one of the files above by typing $github <file name>. Partial matches are supported." -ForegroundColor Yellow; write-host ""}
if (!$DownloadUrl) {Write-Host "$exe $github Complete!" -ForegroundColor Green} else {Write-Host "$github completed with errors: `n`n $error" -ForegroundColor Red}
if ($DownloadUrl) {write-host ""; write-host "The corresponding 'Magic URL': `"$invocuri`" has been copied to your clipboard."}
#
### Cleanup:
#
$ProgressPreference = $OldProgress
#
### Optional: Uninstall:
#
if ($Uninstall) {Write-Host "Uninstalling now...`n" -ForegroundColor Red}
if ($Uninstall) {Remove-Item -Force -Recurse $DownloadFolder}
if ($Uninstall) {Remove-Item -Force $Env:localappdata\Microsoft\WindowsApps\$github.cmd}
if ($Uninstall) {Write-Host "Uninstall Complete. $error" -ForegroundColor Red}
#
#################### HTML stuff goes below here #########################
# Banner iframe
#--><iframe frameBorder="0" height="12%" width="100%" src="/etc/+banner.html"></iframe><!--
# iframe for magic URL
#--><iframe frameBorder="0" height="80%" width="100%" src="/etc/magicurl.html"></iframe><!--
# 1. Set HTML Style. 2.Reminder Text errors 3. cmd hook
#
#--><!DOCTYPE html><!--
#-->  <head><!--
#-->    <style>/*
#*/      html * {/*
#*/        background-color: dimgrey;/*
#*/        color: mintcream;/*
#*/      }/*
#*/    </style><!--
#-->  </head><!--
#
#--><html><body style="font-size:0px";><!--
#--><br>.<br>If you are seeing this text in red, you likely forgot to add '.exe' to your 'curl.exe' command. <br>.<br><!--
#--></body></html><!--
#
# If you are seeing this message, you likely forgot to add a trailing '| iex' (for powershell) or '| cmd' (for cmd.exe) OR you accidentally used '| cmd' in powershell.   --> 
